## 1) Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает. 
Метод запроса OPTIONS является частью протокола HTTP и предназначен для получения информации о возможностях сервера или ресурса.
1) Когда вызывается?
- Клиент может отправить запрос OPTIONS для уточнения поддерживаемых методов запроса (GET, POST, PUT, DELETE и др.) для конкретного ресурса на сервере;
- Клиент также может использовать OPTIONS для проверки возможных CORS ограничений, чтобы убедиться, что он имеет разрешение на выполнение запросов с данного домена.
2) Где используется?
- Взаимодействие между браузерами и серверами в рамках политики безопасности браузера, особенно при выполнении запросов к серверам, не находящимся в том же домене (CORS).
3) Что передает и принимает?
- Запрос OPTIONS не обязан содержать тело, но может содержать заголовки, необходимые для дополнительной информации;
- Ответ OPTIONS включает в себя заголовки, предоставляющие информацию о поддерживаемых методах запроса, дополнительных заголовках и других свойствах ресурса.
  
## 2) Прочитать и описать ключевые особенности "HTTP" Версии 3.0
- **QUIC Протокол**: использует новый транспортный протокол QUIC, который построен поверх протокола UDP (в отличие от TCP в предыдущих версиях HTTP). QUIC обеспечивает более низкую задержку и повышенную производительность;
- **Многопоточность**: поддерживает многопоточность запросов, что позволяет одновременно отправлять и получать несколько запросов и ответов по одному соединению;
- **Быстрая переподключаемость**: имеет быстрый механизм пересылки данных в случае потери пакетов, что способствует более надежной передаче данных в условиях непостоянной сети;
- **Улучшенное управление потоками**: управление потоками улучшено, что позволяет приложениям более эффективно управлять порядком и приоритетами передачи данных;
- **Оптимизация для мобильных сетей**: HTTP/3 разработан с учетом улучшенной производительности на мобильных устройствах и в сетях с высокой задержкой.
  
## 3) Прочитать про способы отмены запроса, включая объект "AbortController"
- **AbortController** это интерфейс, предоставляющий механизм отмены асинхронных операций;
- **setTimeout** установка таймаута для отмены запроса после определенного времени;
- **Промисы и флаги состояния** использование флагов состояния для отслеживания состояния запроса и прерывание выполнения, в процессе выполнения запроса проверяется флаг, если запрос должен быть отменен, то операция завершается преждевременно с соответствующей ошибкой.
  
## 3) Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)
```
//String
let myString = "hello";
let anotherString = String("hello");

//Number
let myNumber = 77;
let anotherNumber = Number("77");

//Boolean
let myBool = true;
let anotherBool = !myBool;
let oneMoreBoolean = Boolean(false);

//Undefined
let myUndefined = undefined;
let anotherUndefined;

//Null
let myNull = null;

//Symbol
let mySymbol = Symbol("symbol");

//BigInt
let myBigInt = 1234567890n;
let anotherBigInt = 12345678900987654321;
let oneMoreBigInt = BigInt(1234);
```

## 4) Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError? 
Переменные объявлены с использованием let и const поднимаются (hoisting), но остаются в "временной мертвой зоне" (TDZ) до момента их фактической инициализации, поэтому обращение к ним до объявления вызывает ReferenceError. Переменные объявленные с помощью var также поднимаются (hoisting), но они сразу же инициализируются значением undefined

## 5) Решить: 
```
const res = "B" + "a" + (1 - "hello");
console.log(res); // "BaNaN"

const res2 = (true && 3) + "d";
console.log(res2); // "3d"

const res3 = Boolean(true && 3) + "d";
console.log(res3); // "trued"
```
